from PIL import Image
import numpy as np
import pickle as pkl
from scipy.fftpack import dct, idct
import matplotlib.pyplot as plt

def RGBtoYCbCr(foto):
    pix = foto.load()
    x, y = foto.size

    image = Image.new("YCbCr", (x, y))

    for i in range (x):
        for j in range (y):
            R,G,B = pix[i,j]

            Y = round(0.299*(R)+0.587*(G)+0.114*(B))
            Cb = round(-0.1687*(R) -0.3313*(G) + 0.5  *(B) + 128)
            Cr = round(0.5  *(R) - 0.4187*(G) - 0.0813*(B) + 128)

            Y = min(max(Y, 0), 255)
            Cb = min(max(Cb, 0), 255)
            Cr = min(max(Cr, 0), 255)

            image.putpixel((i, j), (Y, Cb, Cr))

    return image

def ycbcr_to_rgb(ycbcr):
    x, y = ycbcr.size
    image = Image.new("RGB", (x, y))
    pix = ycbcr.load()


    for i in range (x):
        for j in range (y):
            Y, Cb, Cr = pix[i,j]

            R = round(Y + 1.402 * (Cr-128.))
            G = round(Y - 0.344136 * (Cb-128.) - 0.714136 * (Cr-128.))
            B = round(Y + 1.772 * (Cb-128.))

            image.putpixel((i, j), (R, G, B))

    return image

def downsemp(foto, factor=2):
    pix = foto.load()
    x, y = foto.size

    image = Image.new("YCbCr", (x, y))

    for i in range(0, x, factor):
        for j in range(0, y, factor):
            Cb_color = pix[i, j][1]
            Cr_color = pix[i, j][2]

            for fi in range(factor):
                for fj in range(factor):
                    if i + fi < x and j + fj < y:
                        image.putpixel((i + fi, j + fj), (pix[i + fi, j + fj][0], Cb_color, Cr_color))

    return image

def upsample(foto, factor=2):
    pix = foto.load()
    x, y = foto.size

    # Размеры нового изображения
    new_x = x * factor
    new_y = y * factor

    # Создаем новое изображение
    image = Image.new("YCbCr", (new_x, new_y))

    for i in range(x):
        for j in range(y):
            # Получаем текущий цвет
            Y, Cb, Cr = pix[i, j]

            # Заполняем блок размером factor x factor
            for fi in range(factor):
                for fj in range(factor):
                    if i * factor + fi < new_x and j * factor + fj < new_y:
                        image.putpixel((i * factor + fi, j * factor + fj), (Y, Cb, Cr))

    return image

def splitImg(image, n=8):
    global num_x, num_y
    x, y = image.size

    num_x = (x + n - 1) // n
    num_y = (y + n - 1) // n

    blocksi = []
    blocksj = []
    blocksk = []
    pix = image.load()

    for i in range(num_x):
        for j in range(num_y):
            start_row = i * n
            start_col = j * n
            end_row = min(start_row + n, y)
            end_col = min(start_col + n, x)

            block_height = end_row - start_row
            block_width = end_col - start_col

            if block_height > 0 and block_width > 0:
                blocki = np.zeros((block_height, block_width, 1), dtype=np.uint8)
                blockj = np.zeros((block_height, block_width, 1), dtype=np.uint8)
                blockk = np.zeros((block_height, block_width, 1), dtype=np.uint8)

                for bi in range(block_height):
                    for bj in range(block_width):
                        blocki[bi, bj], blockj[bi, bj],blockk[bi, bj] = pix[bj + start_col, bi + start_row]

                blocksi.append(blocki)
                blocksj.append(blockj)
                blocksk.append(blockk)
    return blocksi, blocksj, blocksk

##def splitImg(image, n=8):
##    global num_x, num_y
##    x, y = image.size
##
##    num_x = (x + n - 1) // n
##    num_y = (y + n - 1) // n
##
##    blocksi = []
##    pix = image.load()
##
##    for i in range(num_x):
##        for j in range(num_y):
##            start_row = i * n
##            start_col = j * n
##            end_row = min(start_row + n, y)
##            end_col = min(start_col + n, x)
##
##            block_height = end_row - start_row
##            block_width = end_col - start_col
##
##            if block_height > 0 and block_width > 0:
##                blocki = np.zeros((block_height, block_width, 1), dtype=np.uint8)
##
##                for bi in range(block_height):
##                    for bj in range(block_width):
##                        blocki[bi, bj] = pix[bj + start_col, bi + start_row]
##
##                blocksi.append(blocki)
##    return blocksi


##def DCTII(matrix):
##    shape = matrix.shape
##    dct_result = np.zeros_like(matrix, dtype=float)
##
##    # Создаем массив индексов
##    N = shape[1]
##    M = shape[2]
##    u = np.arange(N)
##    v = np.arange(M)
##
##    # Создаем сетку координат
##    x = np.arange(N)
##    y = np.arange(M)
##
##    # Вычисляем коэффициенты Cu и Cv
##    Cu = np.where(u[:, None] == 0, 1 / np.sqrt(N), np.sqrt(2 / N))
##    Cv = np.where(v[None, :] == 0, 1 / np.sqrt(M), np.sqrt(2 / M))
##
##    # Вычисляем DCT
##    for i in range(shape[0]):  # Для каждого блока
##        block = matrix[i]
##
##        # Создаем матрицы для вычисления косинусов
##        cos_u = np.cos(((2 * x[:, None] + 1) @ u[None, :]) * np.pi / (2 * N))
##        cos_v = np.cos(((2 * y[None, :] + 1) @ v[:, None]) * np.pi / (2 * M))
##
##        # Вычисляем сумму
##        sum_val = np.sum(block[:, :, None] * cos_u[:, :, None] * cos_v[:, None, :], axis=(0, 1))
##
##        # Умножаем на коэффициенты Cu и Cv
##        dct_result[i] = Cu * Cv * sum_val
##
##    return dct_result
##
##def IDCTII(dct_matrix):
##    # Размеры блока
##    N = 8
##    M = 8
##
##    # Создаем массив индексов
##    u = np.arange(N)
##    v = np.arange(M)
##
##    # Вычисляем коэффициенты Cu и Cv
##    Cu = np.where(u[:, None] == 0, 1 / np.sqrt(N), np.sqrt(2 / N))
##    Cv = np.where(v[None, :] == 0, 1 / np.sqrt(M), np.sqrt(2 / M))
##
##    # Создаем массив для результата
##    idct_result = np.zeros((N, M), dtype=float)
##
##    # Вычисляем IDCT
##    for i in range(N):  # Для каждой строки
##        for j in range(M):  # Для каждого столбца
##            sum_val = 0
##            for u in range(N):  # По всем u
##                for v in range(M):  # По всем v
##                    cos_u = np.cos(((2 * i + 1) * u * np.pi) / (2 * N))
##                    cos_v = np.cos(((2 * j + 1) * v * np.pi) / (2 * M))
##                    sum_val += Cu[u] * Cv[v] * dct_matrix[u, v] * cos_u * cos_v
##            idct_result[i, j] = sum_val
##
##    return np.clip(idct_result, 0, 255).astype(np.uint8)








##def zigzag(matrix):
##    result = []
##
##    n = len(matrix[0])
##    m = len(matrix[0][0])
##
##    for k in matrix:
##        for d in range(n + m - 1):
##            if d % 2 == 0:
##                for i in range(min(d, m - 1), max(-1, d - n), -1):
##                    j = d - i
##                    if 0 <= j < n and 0 <= i < m:
##                        value = k[j][i]
##                        result.append(int(value))
##            else:
##                for i in range(max(0, d - n + 1), min(d + 1, m)):
##                    j = d - i
##                    if 0 <= j < n and 0 <= i < m:
##                        value = k[j][i]
##                        result.append(int(value))
##
##    return result

def zigzag(matrix):
    result = []
    n = len(matrix)  # Количество строк
    m = len(matrix[0])  # Количество столбцов

    for d in range(n + m - 1):
        if d % 2 == 0:  # Четные диагонали
            for i in range(min(d, m - 1), max(-1, d - n), -1):
                j = d - i
                if 0 <= j < n and 0 <= i < m:
                    result.append(int(matrix[j][i]))
        else:  # Нечетные диагонали
            for i in range(max(0, d - n + 1), min(d + 1, m)):
                j = d - i
                if 0 <= j < n and 0 <= i < m:
                    result.append(int(matrix[j][i]))

    return result

def izigzag(arr):
    n, m = 8,8
    matrix = np.zeros((n, m), dtype=float)

    index = 0
    for d in range(n + m - 1):
        if d % 2 == 0:
            for i in range(min(d, m - 1), max(-1, d - n), -1):
                j = d - i
                if 0 <= j < n and 0 <= i < m:
                    matrix[j][i] = arr[index]
                    index += 1
        else:
            for i in range(max(0, d - n + 1), min(d + 1, m)):
                j = d - i
                if 0 <= j < n and 0 <= i < m:
                    matrix[j][i] = arr[index]
                    index += 1

    return matrix

def variable_encoding(x):
    x = np.array(x).astype(int)
    results = []
    for value in x:
        if value == 0:
            l = 1
        else:
            l = 0
            while np.abs(value) >= (2 ** l) :
                l += 1
        if value < 0:
            value = (value + (2 ** (l)))-1
        if l == 0:
            bit_code = '0'
            l+=1
        else:
            bit_code = f'{value:0{l}b}'
        results.append((l, bit_code))
    return results

def var_dec(p):
    result = []
    for i in p:
        l, bin_str = i
        x = int(bin_str,2)
        if x<2**(l-1):
            x-=2**l-1
        result.append(x)
    return result

def DCY(dcY):
    huf = []
    with open('hufTableDClum.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    result = ''

    dcY_new = []
    dcY_new.append(dcY[0])
    prev = dcY[0]
    for cur in dcY[1:]:
        dif = cur-prev
        dcY_new.append(dif)
        prev = cur

    res = []
    res = variable_encoding(dcY_new)

    for j in res:
        lenCH, binCH = j
        for i in huf:
            categ, lenght, codeh = i
            if str(codeh) == '10' or str(codeh)=='11':
                codeh = f"{codeh:03}"
            if str(codeh) == '0':
                codeh = f"{codeh:02}"
            if lenCH==categ:
                result+=(str(codeh)+binCH)
    return result

def DCCbCr(dcCbCr):
    huf = []
    with open('hufTableDCcol.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    result = ''

    dcCbCr_new = []
    dcCbCr_new.append(dcCbCr[0])
    prev = dcCbCr[0]
    for cur in dcCbCr[1:]:
        dif = cur-prev
        dcCbCr_new.append(dif)
        prev = cur

    res = []
    res = variable_encoding(dcCbCr_new)

    for j in res:
        lenCH, binCH = j
        for i in huf:
            categ, lenght, codeh = i
            if str(codeh) == '00':
                codeh = f"{codeh:03}"
            if str(codeh) == '1':
                codeh = f"{codeh:02}"
            if lenCH==categ:
                result+=(str(codeh)+binCH)
    return result

def ACY(data):
    huf = []
    with open('hufTableAClum.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    Ac_new = []
    nulCNT = 0
    for i in data:
        if i==0:
            if nulCNT==15:
                Ac_new.append((15,0))
                nulCNT=-1
            nulCNT+=1
        else:
            Ac_new.append((nulCNT, i))
            nulCNT=0
    if nulCNT != 0:
        Ac_new.append((nulCNT-1, 0))

    result = ''

    res_nul = []
    res_ch = []
    for i in Ac_new:
        res_nul.append(i[0])
        res_ch.append(i[1])

    res = []
    res = variable_encoding(res_ch)

    for i in range(len(res)):
        nulNum = res_nul[i]
        lenCH, binCH = res[i]
        for j in huf:
            nulNumH, chH, lenght, codeh = j
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if nulNum==nulNumH and lenCH == chH:
                result+=(str(codeh)+binCH)


    return result

def ACcbcr(data):
    huf = []
    with open('hufTableACcol.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    Ac_new = []
    nulCNT = 0
    for i in data:
        if i==0:
            if nulCNT==15:
                Ac_new.append((15,0))
                nulCNT=-1
            nulCNT+=1
        else:
            Ac_new.append((nulCNT, i))
            nulCNT=0
    if nulCNT != 0:
        Ac_new.append((nulCNT-1, 0))

    result = ''

    res_nul = []
    res_ch = []
    for i in Ac_new:
        res_nul.append(i[0])
        res_ch.append(i[1])

    res = []
    res = variable_encoding(res_ch)

    for i in range(len(res)):
        nulNum = res_nul[i]
        lenCH, binCH = res[i]
        for j in huf:
            nulNumH, chH, lenght, codeh = j
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if nulNum==nulNumH and lenCH == chH:
                result+=(str(codeh)+binCH)

    return result

def RLE(s: bytes) -> bytes:
    if not s:
        return b''

    compressed = bytearray()
    counter = 1
    Ncounter = 0
    prev_symb = s[0]
    flag = False
    Nep = []

    for symb in s[1:]:
        if prev_symb == symb:
            if flag == True:
                while Ncounter > 127:
                    compressed.append(127 | 0x80)
                    for i in Nep[:127]:
                        compressed.append(i)
                    Ncounter -= 127
                    Nep = Nep[127:]
                compressed.append(Ncounter | 0x80)
                for i in Nep:
                    compressed.append(i)
                flag = False
                Nep = []
                Ncounter = 0
            counter += 1
        else:
            if counter > 1:
                while counter>127:
                    compressed.append(127 & 0x7F)
                    compressed.append(prev_symb)
                    counter -= 127
                compressed.append(counter & 0x7F)
                compressed.append(prev_symb)
                counter = 1
            else:
                if flag == False:
                    flag = True
                Ncounter += 1
                Nep.append(prev_symb)
            prev_symb = symb


    if counter > 1:
        compressed.append(counter & 0x7F)
        compressed.append(prev_symb)
    else:
        compressed.append((1 << 7) | 1)
        compressed.append(prev_symb)

    return bytes(compressed)

def ToBytes(binary_string):
    number = int(binary_string, 2)
    byte_length = (number.bit_length() + 7) // 8
    byte_order = 'big'
    byte_array = number.to_bytes(byte_length, byte_order)
    return byte_array

def BBS(byte_array, lenght):
    bs = ''
    for byte in byte_array:
        bs += ''.join(format(byte, '08b'))
    if len(bs)>lenght:
        bs = bs[(len(bs)-lenght):]
    if len(bs)<lenght:
        bs = f"{bs:0>{lenght}}"
    return bs

##.lstrip('0')

def iRLE(compressed: bytes) -> bytes:
    s = bytearray()
    i = 0
    N = len(compressed)

    while i < N:
        count = compressed[i]
        if count & 0x80:
            count = count & 0x7F
            while count > 0:
                s.append(compressed[i + 1])
                count-=1
                i+=1
            i += 1
        else:
            symb = compressed[i + 1]
            s.extend([symb] * count)
            i += 2

    return bytes(s)

def iDCY(dcY):
    huf = []
    with open('hufTableDClum.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    res = []
    i = 0

    while i < len(dcY):
        found = False
        for j in huf:
            categ, lenght, codeh = j
            if str(codeh) == '10' or str(codeh)=='11':
                codeh = f"{codeh:03}"
            if str(codeh) == '0':
                codeh = f"{codeh:02}"
            if str(dcY[i:i + len(str(codeh))]) == str(codeh):
                res.append((categ, dcY[i + len(str(codeh)):i + len(str(codeh)) + categ]))
                i += len(str(codeh))
                i += categ
                found = True
                break

        if not found:
            i += 1

    res1 = []
    res1 = var_dec(res)

    result = []
    result.append(res1[0])
    prev = res1[0]
    for cur in res1[1:]:
        summ = cur + prev
        result.append(summ)
        prev = summ

    return result

def iDCCBCR(dcCbCr):
    huf = []
    with open('hufTableDCcol.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    res = []
    i = 0

    while i < len(dcCbCr):
        found = False
        for j in huf:
            categ, lenght, codeh = j
            if str(codeh) == '00':
                codeh = f"{codeh:03}"
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if str(dcCbCr[i:i + len(str(codeh))]) == str(codeh):
                res.append((categ,dcCbCr[i + len(str(codeh)):i + len(str(codeh)) + categ]))
                i += len(str(codeh))
                i += categ
                found = True
                break

        if not found:
            i += 1

    res1 = []
    res1 = var_dec(res)

    result = []
    result.append(res1[0])
    prev = res1[0]
    for cur in res1[1:]:
        summ = cur + prev
        result.append(summ)
        prev = summ

    return result

def iACY(data):
    huf = []
    with open('hufTableAClum.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    res_nul = []
    res_ch = []
    i = 0

    while i < len(data):
        found = False
        for j in huf:
            nulh, chh, lenght, codeh = j
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if str(data[i:i + len(str(codeh))]) == str(codeh):
                res_nul.append(nulh)
                res_ch.append((chh, data[i + len(str(codeh)):i + len(str(codeh)) + chh]))
                i += len(str(codeh))
                i += chh
                found = True
                break

        if not found:
            res.append(data[i])
            i += 1

    res1 = []
    res1 = var_dec(res_ch)

    res = []

    for i in range (len(res1)):
        res.append((res_nul[i], res1[i]))

    result = []

    for i in res:
        nul, ch = i
        j=0
        while j<nul:
            result.append(0)
            j+=1
        result.append(ch)

    return result

def iACCBCR(data):
    huf = []
    with open('hufTableACcol.txt', 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                huf.append(list(map(int, line.split())))

    res_nul = []
    res_ch = []
    i = 0

    while i < len(data):
        found = False
        for j in huf:
            nulh, chh, lenght, codeh = j
            if str(codeh) == '0' or str(codeh)=='1':
                codeh = f"{codeh:02}"
            if str(data[i:i + len(str(codeh))]) == str(codeh):
                res_nul.append(nulh)
                res_ch.append((chh, data[i + len(str(codeh)):i + len(str(codeh)) + chh]))
                i += len(str(codeh))
                i += chh
                found = True
                break

        if not found:
            res.append(data[i])
            i += 1

    result = []

    res1 = []
    res1 = var_dec(res_ch)

    res = []

    for i in range (len(res1)):
        res.append((res_nul[i], res1[i]))

    for i in res:
        nul, ch = i
        j=0
        while j<nul:
            result.append(0)
            j+=1
        result.append(ch)

    return result



def mergeImg(Y, Cb, Cr):
    block_height = 8
    block_width = 8
    n = 512
    height = 64 * block_height
    width = 64 * block_width
    reconstructed_image = np.zeros((n, n, 3), dtype=float)

    for i in range(64):
        for j in range(64):
            start_y = i * block_height
            start_x = j * block_width
            block_idx = i * 64 + j

            reconstructed_image[start_y:start_y + block_height, start_x:start_x + block_width, 0] = Y[block_idx][:][:]

            reconstructed_image[start_y:start_y + block_height, start_x:start_x + block_width, 1] = Cb[block_idx][:][:]

            reconstructed_image[start_y:start_y + block_height, start_x:start_x + block_width, 2] = Cr[block_idx][:][:]


    reconstructed_image = np.clip(reconstructed_image, 0, 255)
    reconstructed_image = reconstructed_image.astype(np.uint8)
    return Image.fromarray(reconstructed_image)


def DCTII(block):
    # Применяем ДКТ к блоку 8x8
    return dct(dct(block, axis=0, norm='ortho'), axis=1, norm='ortho')

def IDCTII(dct_block):
    # Применяем обратное ДКТ
    return idct(idct(dct_block, axis=0, norm='ortho'), axis=1, norm='ortho')

def QuantTransf(blocks, quant_matrix):
    result = []
    for block in blocks:
        # Создаем матрицу того же размера, что и блок
        quantized = np.zeros_like(block)
        # Применяем квантование поэлементно
        for i in range(block.shape[0]):
            for j in range(block.shape[1]):
                quantized[i, j] = round(block[i, j] / quant_matrix[i, j])
        result.append(quantized)
    return result

def iQuantTransf(blocks, quant_matrix):
    result = []
    for block in blocks:
        # Создаем матрицу того же размера, что и блок
        dequantized = np.zeros_like(block)
        # Применяем обратное квантование поэлементно
        for i in range(block.shape[0]):
            for j in range(block.shape[1]):
                dequantized[i, j] = block[i, j] * quant_matrix[i, j]
        result.append(dequantized)
    return result


def main():
    img = Image.open(r"C:\Users\ASUS\Desktop\aisd22\lenna.raw")

    c = 100

    qY = np.array([[16, 11, 10, 16, 24, 40, 51, 61],
                                     [12, 12, 14, 19, 26, 58, 60, 55],
                                     [14, 13, 16, 24, 40, 57, 69, 56],
                                     [14, 17, 22, 29, 51, 87, 80, 62],
                                     [18, 22, 37, 56, 68, 109, 103, 77],
                                     [24, 35, 55, 64, 81, 104, 113, 92],
                                     [49, 64, 78, 87, 103, 121, 120, 101],
                                     [72, 92, 95, 98, 112, 100, 103, 99]])*(c*0.001)

    qCbCr = np.array([[17, 18, 24, 47, 99, 99, 99, 99],
                                     [18, 21, 26, 66, 99, 99, 99, 99],
                                     [24, 26, 56, 99, 99, 99, 99, 99],
                                     [47, 66, 99, 99, 99, 99, 99, 99],
                                     [99, 99, 99, 99, 99, 99, 99, 99],
                                     [99, 99, 99, 99, 99, 99, 99, 99],
                                     [99, 99, 99, 99, 99, 99, 99, 99],
                                     [99, 99, 99, 99, 99, 99, 99, 99]])*(c*0.001)

    img = RGBtoYCbCr(img)
    img = downsemp(img)
    blockY, blockCb, blockCr = splitImg(img)

    resultDCY = []
    resultDCCB = []
    resultDCCR = []

    resultACY = []
    resultACCB = []
    resultACCR = []

    for i in range(len(blockY)):
##        for row in blockCr[i]:
##            print([element[0] for element in row])

        dcY = []
        dcCb = []
        dcCr = []

        acY = []
        acCb = []
        acCr = []


        blockiY = DCTII(blockY[i])
        blockiCb = DCTII(blockCb[i])
        blockiCr = DCTII(blockCr[i])

##        for row in blockiCr:
##            print([element[0] for element in row])


        blockiY = QuantTransf(blockiY, qY)
        blockiCb = QuantTransf(blockiCb, qCbCr)
        blockiCr = QuantTransf(blockiCr, qCbCr)

##        print(blockiCr)


        zagY = zigzag(blockiY)
        zagCb = zigzag(blockiCb)
        zagCr = zigzag(blockiCr)



        for j in range (len(zagY)):
            if j%64 == 0:
                dcY.append(zagY[j])
            else:
                acY.append(zagY[j])

        for j in range (len(zagCb)):
            if j%64 == 0:
                dcCb.append(zagCb[j])
            else:
                acCb.append(zagCb[j])

        for j in range (len(zagCr)):
            if j%64 == 0:
                dcCr.append(zagCr[j])
            else:
                acCr.append(zagCr[j])

        resdcY = DCY(dcY)
        resdcCb = DCCbCr(dcCb)
        resdcCr = DCCbCr(dcCr)

        resacY = ACY(acY)
        resacCb = ACcbcr(acCb)
        resacCr = ACcbcr(acCr)


        lenght = len(resdcY)
        resdcY = ToBytes(resdcY)
        resultDCY.append((resdcY,lenght))

        lenght = len(resacY)
        resacY = ToBytes(resacY)
##            resacY = RLE(resacY)
        resultACY.append((resacY,lenght))

        lenght = len(resdcCb)
        resdcCb = ToBytes(resdcCb)
        resultDCCB.append((resdcCb, lenght))

        lenght = len(resacCb)
        resacCb = ToBytes(resacCb)
##            resacCb = RLE(resacCb)
        resultACCB.append((resacCb, lenght))

        lenght = len(resdcCr)
        resdcCr = ToBytes(resdcCr)
        resultDCCR.append((resdcCr,lenght))

        lenght = len(resacCr)
        resacCr = ToBytes(resacCr)
##            resacCr = RLE(resacCr)
        resultACCR.append((resacCr,lenght))




    with open('output_file.txt', 'wb') as f:
        pkl.dump((resultDCY,resultDCCB,resultDCCR),f)
        pkl.dump((resultACY,resultACCB,resultACCR),f)

    ArY = []
    ArCb = []
    ArCr = []

    with open('output_file.txt', 'rb') as f:
        resdcY, resdcCb, resdcCr = pkl.load(f)
##        print(resdcY," ", resdcCb," ", resdcCr)
        resacY,resacCb,resacCr = pkl.load(f)
##        print(resacY," ", resacCb," ", resacCr)
        for i in range(len(resdcY)):

            rDcY, lenghtdY = resdcY[i]
            rDcCb, lenghtdCb = resdcCb[i]
            rDcCr, lenghtdCr = resdcCr[i]

            rAcY, lenghtaY = resacY[i]
            rAcCb, lenghtaCb = resacCb[i]
            rAcCr, lenghtaCr = resacCr[i]

            zigzY = []
            zigzCb = []
            zigzCr = []

            rDcY = BBS(rDcY, lenghtdY)
            rDcCb = BBS(rDcCb, lenghtdCb)
            rDcCr = BBS(rDcCr, lenghtdCr)

##            rAcY = iRLE(resacY[i])
##            rAcCb = iRLE(resacCb[i])
##            rAcCr = iRLE(resacCr[i])

            rAcY = BBS(rAcY, lenghtaY)
            rAcCb = BBS(rAcCb, lenghtaCb)
            rAcCr = BBS(rAcCr, lenghtaCr)

            rDcY = iDCY(str(rDcY))
            rDcCb = iDCCBCR(str(rDcCb))
            rDcCr = iDCCBCR(str(rDcCr))

            rAcY = iACY(str(rAcY))
            rAcCb = iACCBCR(str(rAcCb))
            rAcCr = iACCBCR(str(rAcCr))

            k=0
            z=0
            for j in range (512):
                if z>=len(rAcY):
                    zigzY.append(0)
                elif j%64==0:
                    zigzY.append(rDcY[k])
                    k+=1
                else:
                    zigzY.append(rAcY[z])
                    z+=1

            k=0
            z=0
            for j in range (512):
                if z>=len(rAcCb):
                    zigzCb.append(0)
                elif j%64==0:
                    zigzCb.append(rDcCb[k])
                    k+=1
                else:
                    zigzCb.append(rAcCb[z])
                    z+=1

            k=0
            z=0
            for j in range (512):
                if z>=len(rAcCr):
                    zigzCr.append(0)
                elif j%64==0:
                    zigzCr.append(rDcCr[k])
                    k+=1
                else:
                    zigzCr.append(rAcCr[z])
                    z+=1

            zagresY = []
            for j in range (8):
                aftZagY = izigzag(zigzY[j*64:(j+1)*64])
                zagresY.append(aftZagY)

            zagresCb = []
            for j in range (8):
                aftZagCb = izigzag(zigzCb[j*64:(j+1)*64])
                zagresCb.append(aftZagCb)

            zagresCr = []
            for j in range (8):
                aftZagCr = izigzag(zigzCr[j*64:(j+1)*64])
                zagresCr.append(aftZagCr)

##            print(zagresCr[0])

            QY = iQuantTransf(zagresY, qY)
            QCb = iQuantTransf(zagresCb, qCbCr)
            QCr = iQuantTransf(zagresCr, qCbCr)
##
##            print(QCr)

            QY1 = IDCTII(QY[0])
            QCb1 = IDCTII(QCb[0])
            QCr1 = IDCTII(QCr[0])

            ArY.append(QY1)
            ArCb.append(QCb1)
            ArCr.append(QCr1)

        resimg = mergeImg(ArY, ArCb, ArCr)
        resimg = upsample(resimg)
        resimg1 = ycbcr_to_rgb(resimg)

        resimg1.show()





if __name__ == '__main__':
    main()
